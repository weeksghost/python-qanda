BUILT-INS:

all() —- Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to:

    def all(iterable):
        for element in iterable:
            if not element:
                return False
        return True

repr() —- Return a string containing a printable representation of an object.

====================================================================================

STRINGS:

s.lower(), s.upper() -- returns the lowercase or uppercase version of the string

s.strip() -- returns a string with whitespace removed from the start and end

s.isalpha()/s.isdigit()/s.isspace()... -- tests if all the string chars are in the various 
character classes

s.startswith('other'), s.endswith('other') -- tests if the string starts or ends with the given other string

s.find('other') -- searches for the given other string (not a regular expression) within s, and returns the first index where it begins or -1 if not found

s.replace('old', 'new') -- returns a string where all occurrences of 'old' have been replaced by 'new'

s.split('delim') -- returns a list of substrings separated by the given delimiter. The delimiter is not a regular expression, it's just text. 'aaa,bbb,ccc'.split(',') -> ['aaa', 'bbb', 'ccc']. As a convenient special case s.split() (with no arguments) splits on all whitespace chars.

s.join(list) -- opposite of split(), joins the elements in the given list together using the string as the delimiter. e.g. '---'.join(['aaa', 'bbb', 'ccc']) -> aaa---bbb---ccc

====================================================================================

DATA TYPES:


tuple() —- A tuple consists of a number of values separated by commas

set() —- Return a new set or frozenset object whose elements are taken from iterable. The elements of a set must be hashable

map() —- Apply function to every item of iterable and return a list of the results.

====================================================================================

GLOSSARY:


List Comprehensions:

The syntax is [ expr for var in list ] -- the for var in list looks like a regular for-loop, but without the colon (:). The expr to its left is evaluated once for each element to give the values for the new list.

  nums = [1, 2, 3, 4]

  for n in nums:
    return n * n

	OR

  squares = [ n * n for n in nums ]

  ————————————————————————————————-

  ## Select values <= 2
  nums = [2, 8, 1, 6]

  for n in nums:
    if n <=2:
        return n

	OR

  small = [ n for n in nums if n <= 2 ]  ## [2, 1]

  ————————————————————————————————-

  ## Select fruits containing 'a', change to upper case
  fruits = ['apple', 'cherry', 'bannana', 'lemon']

  for s in fruits:
    if ‘a’ in s:
	return s.upper()

	OR

  afruits = [ s.upper() for s in fruits if 'a' in s ]
  ## ['APPLE', 'BANNANA']


  ————————————————————————————————-

 Increment Operator: +=

Add AND assignment operator, It adds right operand to the left operand and assigns the result to left operand.

	c += a is equivalent to c = c + a


Slicing:

Refer to sub-parts of sequences

 +---+---+---+---+---+---+
 | p | y | t | h | o | n |
 +---+---+---+---+---+---+
   0   1   2   3   4   5
  -6  -5  -4  -3  -2  -1

s[1:4] is ‘yth’  —- chars starting at index 1 and extending up to but not including index 4
s[1:] is ‘ytho’ —- omitting either index defaults to the start or end of the string
s[:] is ‘python’ —- omitting both always gives us a copy of the whole thing (this is the pythonic way to copy a sequence like a string or list)
s[1:100] is ‘ytho’ —- an index that is too big is truncated down to the string length

The standard zero-based index numbers give easy access to chars near the start of the string. As an alternative, Python uses negative numbers to give easy access to the chars at the end of the string: s[-1] is the last char 'o', s[-2] is 'l' the next-to-last char, and so on. Negative index numbers count back from the end of the string:

s[-1] is ’n’ -- last char (1st from the end)
s[-4] is ’t’ —- 4th from the end
s[:-3] is ‘pyt’  -- going up to but not including the last 3 chars
s[-3:] is ‘hon’ -- starting with the 3rd char from the end and extending to the end of the string


hashable —- An object is hashable if it has a hash value which never changes during its lifetime

lambda:

Lambda expressions (sometimes called lambda forms) have the same syntactic position as expressions.

They are a shorthand to create anonymous functions; the expression yields a function object:

	lambda argument_list: expression

The unnamed object behaves like a function object defined with:

	def name(arguments):
	    return expression